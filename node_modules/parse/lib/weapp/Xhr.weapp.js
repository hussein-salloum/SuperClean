"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.polyfillFetch = polyfillFetch;
var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/reduce"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));
/* istanbul ignore file */

// @ts-ignore
function parseResponse(res) {
  var _context;
  let headers = res.header || {};
  headers = (0, _reduce.default)(_context = (0, _keys.default)(headers)).call(_context, (map, key) => {
    map[key.toLowerCase()] = headers[key];
    return map;
  }, {});
  return {
    status: res.statusCode,
    json: () => {
      if (typeof res.data === 'object') {
        return _promise.default.resolve(res.data);
      }
      let json = {};
      try {
        json = JSON.parse(res.data);
      } catch (err) {
        console.error(err);
      }
      return _promise.default.resolve(json);
    },
    headers: {
      keys: () => (0, _keys.default)(headers),
      get: n => headers[n.toLowerCase()],
      has: n => n.toLowerCase() in headers,
      entries: () => {
        const all = [];
        for (const key in headers) {
          if (headers[key]) {
            all.push([key, headers[key]]);
          }
        }
        return all;
      }
    }
  };
}
function polyfillFetch() {
  const typedGlobal = global;
  if (typeof typedGlobal.fetch !== 'function') {
    typedGlobal.fetch = (url, options) => {
      const dataType = url.match(/\.(txt|json|html|txt|csv)/) ? 'text' : 'arraybuffer';
      return new _promise.default((resolve, reject) => {
        // @ts-ignore
        wx.request({
          url,
          method: options.method || 'GET',
          data: options.body,
          header: options.headers,
          dataType,
          responseType: dataType,
          success: response => resolve(parseResponse(response)),
          fail: error => reject(error)
        });
      });
    };
  }
}